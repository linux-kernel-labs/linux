============
Introduction
============

Lab objectives
==============

* presenting the rules and objectives of the Operating Systems 2 lab
* introducing the lab documentation
* introducing the Linux kernel and related resources

Keywords
========

*  kernel, kernel programming
*  Linux, vanilla, http://www.kernel.org
*  cscope, LXR
*  gdb, /proc/kcore, addr2line, dump\_stack

About this laboratory
=====================

The Operating Systems 2 lab is a kernel programming and driver development lab. 
The objectives of the laboratory are:

* deepening the notions presented in the course
* presentation of kernel programming interfaces (kernel API)
* gaining documenting, development and debugging skills on a freestanding 
  environment
* acquiring knowledge and skills for drivers development

A laboratory will present a set of concepts, applications and commands
specific to a given problem. The lab will start with a presentation
(each lab will have a set of slides) (15 minutes) and the remaining
time will be allocated to the lab exercises (80 minutes).

For best laboratory performance, we recommend that you read the related slides. 
To fully understand a laboratory, we recommend going through the lab support. For
in-depth study, use the supporting documentation.

Documentation
=============

-  Linux

   -  `Linux Kernel Development, 3rd
      Edition <http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468/>`__
   -  `Linux Device Drivers, 3rd
      Edition <http://free-electrons.com/doc/books/ldd3.pdf>`__
   -  `Essential Linux Device
      Drivers <http://www.amazon.com/Essential-Device-Drivers-Sreekrishnan-Venkateswaran/dp/0132396556>`__

-  General

   -  `mailing list <http://cursuri.cs.pub.ro/cgi-bin/mailman/listinfo/pso>`__
      (`searching the mailing list <http://blog.gmane.org/gmane.education.region.romania.operating-systems-design>`__)

Source code navigation
======================

cscope
------

`Cscope <http://cscope.sourceforge.net/>`__ is a tool for
efficient navigation of C sources. To use it, a cscope database must 
be geberated from the existing sources. In a Linux tree, the command
:command:`make ARCH = x86 cscope` is sufficient. Specification of the 
architecture through the ARCH variable is optional but recommended; 
otherwise, some architecture dependent functions will appear multiple 
times in the database.

Cscope can also be used as stand-alone, but it is more useful when 
combined with an editor. To use cscope with Vim, it is necessary to
install both packages and add the following lines to the file
:file:`.vimrc` (the machine in the lab already has the settings):

.. code-block:: vim

    if has("cscope")
            " Look for a 'cscope.out' file starting from the current directory,
            " going up to the root directory.
            let s:dirs = split(getcwd(), "/")
            while s:dirs != []
                    let s:path = "/" . join(s:dirs, "/")
                    if (filereadable(s:path . "/cscope.out"))
                            execute "cs add " . s:path . "/cscope.out " . s:path . " -v"
                            break
                    endif
                    let s:dirs = s:dirs[:-2]
            endwhile

            set csto=0  " Use cscope first, then ctags
            set cst     " Only search cscope
            set csverb  " Make cs verbose

            nmap `<C-\>`s :cs find s `<C-R>`=expand("`<cword>`")`<CR>``<CR>`
            nmap `<C-\>`g :cs find g `<C-R>`=expand("`<cword>`")`<CR>``<CR>`
            nmap `<C-\>`c :cs find c `<C-R>`=expand("`<cword>`")`<CR>``<CR>`
            nmap `<C-\>`t :cs find t `<C-R>`=expand("`<cword>`")`<CR>``<CR>`
            nmap `<C-\>`e :cs find e `<C-R>`=expand("`<cword>`")`<CR>``<CR>`
            nmap `<C-\>`f :cs find f `<C-R>`=expand("`<cfile>`")`<CR>``<CR>`
            nmap `<C-\>`i :cs find i ^`<C-R>`=expand("`<cfile>`")`<CR>`$`<CR>`
            nmap `<C-\>`d :cs find d `<C-R>`=expand("`<cword>`")`<CR>``<CR>`

            " Open a quickfix window for the following queries.
            set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
    endif

The script searches for a file called :file:`cscope.out` in the current directory, or
in parent directories. If Vim finds this file, you can use the shortcut :code:`Ctrl +]`
or :code:`Ctrl+\ g` (the combination control-\\ followed by g) to jump directly to 
the definition of the word under the cursor (function, variable, structure, etc.). 
Similarly, you can use :code:`Ctrl+\ s` to go where the word under the cursor is used.

You can take a cscope-enabled '.vimrc' file (also contains other goodies) from
https://github.com/ddvlad/cfg/blob/master/\_vimrc.
The following guidelines are based on this file, but also show basic vim commands 
that have the same effect.

If there are more than one results (usually there are) you can move between them
using :code:`F6` and :code:`F5` (:code:`:ccnext`  and :code:`:cprev`).
You can also open a new panel showing the results using :code:`:copen`. To close
the panel, use the :code:`:cclose` command.

To return to the previous location, use :code:`Ctrl+o` (o, not zero).
The command can be used multiple times and works even if cscope changed the
file you are currently editing.

To go to a symbol definition directly when vim starts, use :code:`vim -t <symbol_name>`
(for example :code:`vim -t task_struct`). Otherwise, if you started vim and want
to search for a symbol by name, use :code:`cs find g <symbol_name>` (for example
:code:`cs find g task_struct`).

If you fond more than one results and opened a panel showing all the matches
(using :code:`:copen`) and you want to find a symbol of type structure,
it is recommended to search in the results panel (using :code:`/` -- slash)
the character :code:`{` (opening brace).

.. important::
    You can get a summary of all the :command:`cscope` commands using :command:`:cs help`.

    For more info, use the Vim built-in help command: :command:`:h cscope` or :command:`:h copen`.

If you use :command:`emacs`, install the :code:`xcscope-el` package and
add the following lines in :file:`~/.emacs`.

.. code-block:: vim

    (require â€˜xcscope)
    (cscope-setup)

These commands will activate cscope for the C and C++ modes automatically.
:code:`C-s s` is the key bindings prefix and :code:`C-s s s` is used to
search for a symbol (if you call it when the cursor is over a word,
it will use that). For more details, check `https://github.com/dkogan/xcscope.el`

Kscope
~~~~~~

For a simpler interface, `Kscope <http://sourceforge.net/projects/kscope/>`__ 
is a cscope frontend which uses QT. It is lightweight, very fast and very
easy to use. It allows searching using regular expressions, call graphs, etc.
Kscope is no longer mantained.

There is also a `port <https///opendesktop.org/content/show.php/Kscope4?content=156987>`__
of version 1.6 for Qt4 and KDE 4 which keeps the integration of the text
editor Kate and is easier to use than the last version on SourceForge.

LXR Cross-Reference
-------------------

LXR (LXR Cross-Reference) is a tool that allows indexing and
referencing the symbols in the source code of a program using
a web interface. The web interface shows links to
locations in files where a symbol is defined or used. Development website
for LXR is http://sourceforge.net/projects/lxr. Similar tools
are `OpenGrok <http://www.opensolaris.org/os/project/opengrok/>`__ and
`Gonzui <http://en.wikipedia.org/wiki/Gonzui>`__.

Although LXR was originally intended for the Linux kernel sources, it is
also used in the sources of `Mozilla <http://lxr.mozilla.org/>`__, 
`Apache HTTP Server <http://apache.wirebrain.de/lxr/>`__ and
`FreeBSD <http://lxr.linux.no/freebsd/source>`__.

There are a number of sites that use LXR for cross-referencing the
the sources of the Linux kernel, the main site being `the original site of
development <http://lxr.linux.no/linux/>`__ which does not work anymore. You can
use `https://elixir.bootlin.com/ <https://elixir.bootlin.com/>`__.

LXR allows searching for an identifier (symbol), after a free text
or after a file name. The main feature and, at the same
time, the main advantage provided is the ease of finding the declaration
of any global identifier. This way, it facilitates quick access to function 
declarations, variables, macro definitions and the code can be easily 
navigated. Also, the fact that it can detect what code areas are affected 
when a variable or function is changed is a real advantage in the development 
and debugging phase.

SourceWeb
---------

`SourceWeb <http://rprichard.github.io/sourceweb/>`__ is a source code indexer
for C and C++. It uses the 
`framework <http://clang.llvm.org/docs/IntroductionToTheClangAST.html>`__
provided by the Clang compiler to index the code.

The main difference between cscope and SourceWeb is the fact that SourceWeb
is, in a way, a compiper pass. SourceWeb doesn't index all the code, but
only the coe that was efectively compiled by the compiler. This way, some
problems are eliminated, such as ambiguities about which variant of a function
defined in multiple places is used. This also means that the indexing takes
more time, because the compiled files must pass one more time through
the indexer to generate the references.

Usage example:

.. code-block:: bash

    make oldconfig
    sw-btrace make -j4
    sw-btrace-to-compile-db
    sw-clang-indexer --index-project
    sourceweb index

:file:`sw-btrace` is a scrit that adds the :file:`libsw-btrace.so`
library to :code:`LD_PRELOAD`. This way, the library is loaded by
every process started by :code:`make` (basically, the compiler),
registers the commands used to start the processes and generates
a filed called :file:`btrace.log`. This file is then used by 
:code:`sw-btrace-to-compile-db` which converts it to a format defined
by clang: `JSON Compilation Database <http://clang.llvm.org/docs/JSONCompilationDatabase.html>`__.
This JSON Compilation Database resulted from the above steps is then
used by the indexer, which makes one more pass through the compiled
source files and generates the index used by the GUI.

Word of advice: don't index the sources you are working with, but use
a copy, because SourceWeb doesn't have, at this moment, the capability
to regenerate the index for a single file and you will have to regenerate
the complete index.

Debugging
=========

Debugging a kernel is a much more difficult process than the debugging
of a program, because there is no support from the operating system.
This is why this process is usually done using two computers, connected
on serial interfaces.

gdb (Linux)
-----------

A simpler debug method on Linux, but with many disadvantages,
is local debugging, using `gdb <http://www.gnu.org/software/gdb/>`__,
the uncompressed kernel image (:file:`vmlinux`) and :file:`/proc/kcore`
(the real-time kernel image). This method is usually used to inspect
the kernel and detect certain inconsistencies while it runs. The
method is useful especially if the kernel was compiled using the
:code:`-g` option, which keeps debug information. Some well-known 
debug techniques can't be used by this method, such as breakpoints
of data modification.

The uncompressed kernel image offers information about the data structures
and symbols it contains.

.. code-block:: bash

    so2@spook$ cd /usr/src/linux
    so2@spook$ file vmlinux
    vmlinux: ELF 32-bit LSB executable, Intel 80386, ...
    so2@spook$ nm vmlinux | grep sys_call_table
    c02e535c R sys_call_table
    so2@spook$ cat System.map | grep sys_call_table
    c02e535c R sys_call_table

The :command:`nm` utility is used to show the symbols in an object or
executable file. In our case, :file:`vmlinux` is an ELF file. Alternately,
we can use the file :file:`System.map` to view information about the
symbols in kernel.

Then we use :command:`gdb` to inspect the symbols using the uncompressed
kernel image. A simple :command:`gdb` session is the following:

.. code-block:: bash

    so2@spook$ cd /usr/src/linux
    so2@spook$ gdb --quiet vmlinux
    Using host libthread_db library "/lib/tls/libthread_db.so.1".
    (gdb) x/x 0xc02e535c
    0xc02e535c `<sys_call_table>`:    0xc011bc58
    (gdb) x/16 0xc02e535c
    0xc02e535c `<sys_call_table>`:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
    0xc02e536c `<sys_call_table+16>`: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
    0xc02e537c `<sys_call_table+32>`: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
    0xc02e538c `<sys_call_table+48>`: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
    (gdb) x/x sys_call_table
    0xc011bc58 `<sys_restart_syscall>`:       0xffe000ba
    (gdb) x/x &sys_call_table
    0xc02e535c `<sys_call_table>`:    0xc011bc58
    (gdb) x/16 &sys_call_table
    0xc02e535c `<sys_call_table>`:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
    0xc02e536c `<sys_call_table+16>`: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
    0xc02e537c `<sys_call_table+32>`: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
    0xc02e538c `<sys_call_table+48>`: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
    (gdb) x/x sys_fork
    0xc01013d3 `<sys_fork>`:  0x3824548b
    (gdb) disass sys_fork
    Dump of assembler code for function sys_fork:
    0xc01013d3 `<sys_fork+0>`:        mov    0x38(%esp),%edx
    0xc01013d7 `<sys_fork+4>`:        mov    $0x11,%eax
    0xc01013dc `<sys_fork+9>`:        push   $0x0
    0xc01013de `<sys_fork+11>`:       push   $0x0
    0xc01013e0 `<sys_fork+13>`:       push   $0x0
    0xc01013e2 `<sys_fork+15>`:       lea    0x10(%esp),%ecx
    0xc01013e6 `<sys_fork+19>`:       call   0xc0111aab `<do_fork>`
    0xc01013eb `<sys_fork+24>`:       add    $0xc,%esp
    0xc01013ee `<sys_fork+27>`:       ret
    End of assembler dump.

It can be noticed that the uncompressed kernel image was used as an argument
for :command:`gdb`. The image can be found in the root of the kernel sources
after compilation.

A few commands used for debugging using :command:`gdb` are:

- :command:`x` (examine) -- used to show the contents of the memory area
  whose address is specified as an argument to the command (this address
  can be the value of a physical address, a symbol or the address of a
  symbol). It can take as arguments (preceded by :code:`/`): the format
  to display the data in (:code:`x` for hexadecimal, :code:`d` for
  decimal, etc), how many memory units to display and the size of a
  memory unit.

- :command:`disassemble` - Used to disassemble a function.

- :command:`p` (print) - Used to evaluate and show the value of an
  expression. The format to show the data in can be specified as
  an argument (:code:`/x` for hexadecimal, :code:`/d` for decimal, etc.).

The analysis of the kernel image is a method of static analysis. If we
want to perform dynamic analysis (analyzing how the kernel runs, not
only its static image) we can use :file:`/proc/kcore`; this is a dynamic
image (in memory) of the kernel.

.. code-block:: bash

    so2@spook$ gdb /usr/src/linux/vmlinux /proc/kcore
    Core was generated by `root=/dev/hda3 ro'.
    #0  0x00000000 in ?? ()
    (gdb) p sys_call_table
    $1 = -1072579496
    (gdb) p /x sys_call_table
    $2 = 0xc011bc58
    (gdb) p /x &sys_call_table
    $3 = 0xc02e535c
    (gdb) x/16 &sys_call_table
    0xc02e535c `<sys_call_table>`:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
    0xc02e536c `<sys_call_table+16>`: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
    0xc02e537c `<sys_call_table+32>`: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
    0xc02e538c `<sys_call_table+48>`: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725

Using the dynamic image of the kernel is useful for detecting `rootkits <http://en.wikipedia.org/wiki/Rootkit>`__.

- `Linux Device Drivers 3rd Edition - Debuggers and Related Tools <http://linuxdriver.co.il/ldd3/linuxdrive3-CHP-4-SECT-6.html>`__
- `Detecting Rootkits and Kernel-level Compromises in Linux <http://www.securityfocus.com/infocus/1811>`__
- `User-Mode Linux <http://user-mode-linux.sf.net/>`__

Getting a stack trace
---------------------

Somethimes, you will want information about the trace the execution
reaches a certain point. You can determine this information using 
:command:`cscope` or LXR, but some function are called from many
execution paths, which makes this method difficult.

In these situations, it is useful to get a stack trace, which can be
simply done using the function :code:`dump_stack()`.

Documentation
=============

Kernel development is a difficult process, compared to user space
programming. The API is different and the complexity of the subsystems
in kernel requires additional preparation. The associated documentation
is heterogeneous, sometimes requiring the inspection of multiple sources
to have a more complete understanding of a certain aspect.

The main advantages of the Linux kernel are the access to sources and
the open development system. Because of this, the Internet offers a
larger number of documentation for kernel.

A few links related to the Linux kernel are shown bellow:

- `KernelNewbies <http://kernelnewbies.org>`__
- `KernelNewbies - Kernel Hacking <http://kernelnewbies.org/KernelHacking>`__
- `Kernel Analysis - HOWTO <http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO.html>`__
- `Linux Kernel Programming <http://web.archive.org/web/20090228191439/http://www.linuxhq.com/lkprogram.html>`__
- `Linux kernel - Wikibooks <http://en.wikibooks.org/wiki/Linux_kernel>`__

The links are not comprehensive. Using  `The Internet <http://www.google.com>`__ and
`surselor <http://lxr.free-electrons.com/>`__ is essential.

Exercices
=========

Remarks
-------

.. note::

  -  Usually, the steps used to develop a kernel module are the
     following:
  
     -  editing the module source code (on the physical machine);
     -  module compilation (on the physical machine)
     -  generation of the minimal image for the virtual machine.
        This image contains the kernel, your module, busybox and
        eventually test programs.
     -  starting the virtual machine using qemu.
     -  running the tests in the virtual machine.
  
  -  When using cscope, use :file:`~/src/linux`.
     If there is no :file:`cscope.out` file, you can generate it using
     the command :command:`make ARCH=x86 cscope`.

  -  You cand find more details about the virtual machine at 
     :ref:`vm_link`.

.. important::
    Before solving an exercice, **carefully** read all its bullets.

1. Booting the virtual machine
------------------------------

A summary of the virtual machine infrastructure:

-  :file:`~/src/linux` - Linux kernel sources, needed to
   compile modules. The directory contains the file :file:`cscope.out`,
   used for navigation in the source tree.

-  :file:`~/src/linux/tools/labs/qemu`- scripts and auxiliary
   files used to generate and run the qemu VM.

To start the VM, run :command:`QEMU_DISPLAY=sdl make boot` in the directory :file:`~/src/linux/tools/labs`:

.. code-block:: shell

    student@eg106:~$ cd ~/src/linux/tools/labs
    student@eg106:~/src/linux/tools/labs$ QEMU_DISPLAY=sdl make boot

.. note::
    To access the virtual machine, at the login prompt, enter the 
    username :code:`root`; there is no need to enter a password.
    The virtual machine will start with the permissions of the
    root account.

2. AdÄƒugarea È™i utilizarea unui disc virtual
--------------------------------------------

.. note:: 
    If you don't have the file :file:`mydisk.img`, you can download
    it from the address http://elf.cs.pub.ro/so2/res/laboratoare/mydisk.img.

In the directory :file:`~/src/linux/tools/labs/qemu` you have a new virtual
machine disk, in the file :file:`mydisk.img`. We want to add the disk
to the virtual machine and used while it is running.

EditaÈ›i fiÈ™ierul ''Makefile'' pentru a adÄƒuga, la target-ul ''run'',
parametrul ''-drive file=mydisk.img,format=raw''. RulaÈ›i ''make'' pentru
a boota maÈ™ina virtualÄƒ.

ÃŽn cadrul maÈ™inii virtuale configuraÈ›i accesul la disc.

``<note tip>`` Nu trebuie sÄƒ creaÈ›i manual intrarea aferentÄƒ noului disc
Ã®n ''/dev'' pentru cÄƒ maÈ™ina virtualÄƒ foloseÈ™te devtmpfs. ``</note>``

CreaÈ›i directorul ''/test'' È™i Ã®ncercaÈ›i sÄƒ montaÈ›i noul
disc:\ ``<code>`` mkdir /test mount /dev/sda /test ``</code>``

Motivul pentru care nu putem monta discul este pentru cÄƒ nu avem suport
Ã®n kernel pentru sistemul de fiÈ™iere cu care este formatat discul
''mydisk.img''. Va trebui sÄƒ identificaÈ›i sistemul de fiÈ™iere aferent
discului ''mydisk.img'' È™i sÄƒ compilaÈ›i suport Ã®n kernel pentru acel
sistem de fiÈ™iere.

ÃŽnchideÈ›i maÈ™ina virtualÄƒ (Ã®nchideÈ›i fereastra qemu, nu e nevoie sÄƒ
folosiÈ›i altÄƒ comandÄƒ). FolosiÈ›i comanda ''file'' pe maÈ™ina fizicÄƒ
pentru a afla cu ce sistem de fiÈ™iere este formatat fiÈ™ierul
''mydisk.img''. VeÈ›i identifica sistemul de fiÈ™iere ''btrfs''.

Va trebui sÄƒ activaÈ›i suportul de ''btrfs'' Ã®n kernel È™i sÄƒ Ã®l
recompilaÈ›i.

``<note warning>`` DacÄƒ Ã®n momentul executÄƒrii comenzii ''make
menuconfig'' vÄƒ apare eroare, este probabil cÄƒ nu aveÈ›i instalat
pachetul ''libncurses5-dev''. InstalaÈ›i-l folosind comanda

::

    sudo apt-get install libncurses5-dev

``</note>``

``<note tip>`` IntraÈ›i Ã®n subdirectorul ''linux-4.9.11/''. ExecutaÈ›i
''make menuconfig'' È™i intraÈ›i Ã®n secÈ›iunea *File systems*. ActivaÈ›i
opÈ›iunea *Btrfs file system support*. Va trebui sÄƒ folosiÈ›i opÈ›iune de
tip ''builtin'' (**nu** modul) adicÄƒ trebuie sÄƒ aparÄƒ ``<*>`` Ã®n dreptul
opÈ›iunii (**nu** ``<M>``).

SalvaÈ›i configuraÈ›ia realizatÄƒ. FolosiÈ›i fiÈ™ierul de configurare
implicit ''.config''.

ÃŽn subdirectorul cu sursele nucleului (''linux-4.9.11/'') recompilaÈ›i
folosind comanda

::

    make

Pentru a aÈ™tepta mai puÈ›in, puteÈ›i utiliza opÈ›iunea ''-j'' pentru a
folosi mai multe job-uri Ã®n paralel. ÃŽn general se recomandÄƒ un numÄƒr de
procese cu 1 mai mare decÃ¢t numÄƒrul procesoarelor:

::

    make -j5

``</note>``

DupÄƒ ce se Ã®ncheie recompilarea, **reporniÈ›i** maÈ™ina virtualÄƒ QEMU:
adicÄƒ lansaÈ›i comanda ''make'' Ã®n subdirectorul ''qemu-so2/''. Nu este
nevoie sÄƒ copiaÈ›i nimic, pentru cÄƒ fiÈ™ierul ''bzImage'' este symlink
cÄƒtre imaginea kernel-ului pe care tocmai l-aÈ›i recompilat.

ÃŽn cadrul maÈ™inii virtuale QEMU repetaÈ›i operaÈ›iunile de ''mkdir'' È™i
''mount''. AvÃ¢nd suport pentru sistemul de fiÈ™iere btrfs, acum mount se
va termina cu succes.

``<note>`` ÃŽn elaborarea temelor nu este necesar sÄƒ recompilaÈ›i
kernel-ul, veÈ›i folosi doar module. TotuÈ™i, este important sÄƒ fiÈ›i
familiari cu configurarea È™i recompilarea unui kernel.

DacÄƒ totuÈ™i aveÈ›i de gÃ¢nd sÄƒ recompilaÈ›i kernel-ul, faceÈ›i un back-up
fiÈ™ierului ''bzImage'' (urmaÈ›i link-ul din ''qemu-so2'' pentru calea
completÄƒ). Astfel veÈ›i putea reveni la setup-ul iniÈ›ial pentru a avea un
mediu identic cu vmchecker. ``</note>``

3. GDB È™i qemu
--------------

Putem investiga Ã®n timp real È™i depana maÈ™ina virtualÄƒ QEMU.

Pentru aceasta pornim, Ã®n primÄƒ fazÄƒ, maÈ™ina virtualÄƒ QEMU. Apoi, ne
putem conecta cu ''gdb'' la un maÈ™ina vitualÄƒ QEMU **aflatÄƒ Ã®n rulare**,
folosind comanda

::

    :::bash
    make gdb

Am folosit comanda ''qemu'' cu parametrul ''-s'', ceea ce Ã®nseamnÄƒ cÄƒ
ascultÄƒ pe portul 1234 de la GDB. Putem face debugging folosind un
*target remote* pentru GDB. Makefile-ul existent are grijÄƒ de detalii.

CÃ¢nd ataÈ™aÈ›i un debugger unui proces, procesul este suspendat. PuteÈ›i
pune breakpoints È™i inspecta starea curentÄƒ a procesului.

AtaÈ™aÈ›i-vÄƒ la maÈ™ina virtualÄƒ ''qemu'' (folosind comanda ''make gdb'')
È™i puneÈ›i un breakpoint Ã®n funcÈ›ia ''sys\_access'' folosind Ã®n consola
GDB comanda

::

    break sys_access

ÃŽn acest moment maÈ™ina virtualÄƒ este suspendatÄƒ. Pentru a continua
execuÈ›ia ei (pÃ¢nÄƒ la eventualul apel al funcÈ›iei ''sys\_access'')
folosiÈ›i, Ã®n consola GDB comanda\ ``<code>`` continue ``</code>``

ÃŽn acest moment maÈ™ina virtualÄƒ este activÄƒ È™i are consola utilizabilÄƒ.
Pentru a genera un apel de ''sys\_access'', lansaÈ›i o comandÄƒ ''ls''.
ObservaÈ›i cÄƒ maÈ™ina virtualÄƒ a fost din nou suspendatÄƒ de GDB È™i a
apÄƒrut mesajul aferent de apel al ''sys\_access'' Ã®n cadrul GDB.

UrmÄƒriÈ›i execuÈ›ia codului, folosind ''step instruction'', ''continue''
sau ''next instruction''. Probabil nu o sÄƒ Ã®nÈ›elegeÈ›i tot ce se
Ã®ntÃ¢mplÄƒ, utilizaÈ›i comenzi precum ''list'' È™i ''backtrace'' pentru a
urmÄƒri logic execuÈ›ia.

``<hidden>`` RD: Nu È™tiu dacÄƒ ar trebui sau nu sÄƒ se poatÄƒ vedea codul
sursÄƒ. Pe moment dÄƒ eroare cÄƒ nu se vede. O fi ceva de la symlink-uri,
nu m-am prins. ``</hidden>``

``<note tip>`` La prompt-ul ''gdb'', puteÈ›i apÄƒsa ''ENTER'' (fÄƒrÄƒ
altceva) pentru a rula ultima comandÄƒ Ã®ncÄƒ o datÄƒ. ``</note>``

4. GDB spelunking
-----------------

FolosiÈ›i ''GDB'' pentru a afiÈ™a codul sursÄƒ al funcÈ›iei care creeazÄƒ
thread-uri de kernel (''kernel\_thread'').

``<note tip>`` PuteÈ›i folosi GDB pentru analiza staticÄƒ a imaginii de
kernel folosind, Ã®n directorul cu sursele kernel-ului, o comandÄƒ de
forma

::

    gdb vmlinux

ParcurgeÈ›i secÈ›iunea `gdb (Linux) <#gdb%20(Linux)>`__ din laborator.
``</note>``

FolosiÈ›i ''GDB'' pentru a afla adresa variabilei ''jiffies'' Ã®n memorie
È™i conÈ›inutul acesteia. Variabila ''jiffies'' reÈ›ine numÄƒrul de tick-uri
(bÄƒtÄƒi de ceas) de la pornirea sistemului,.

``<note tip>`` Pentru a urmÄƒri valoarea variabilei ''jiffies'' folosiÈ›i
analiza dinamicÄƒ Ã®n GDB folosind comanda

::

    make gdb
    `</code>` la fel ca la [[#gdb_si_qemu|exerciÈ›iul anterior]].

    ParcurgeÈ›i secÈ›iunea [[#gdb (Linux)|gdb (Linux)]] din laborator.
    `</note>`

    `<note tip>`
    Variabila ''jiffies'' este pe 64 de biÈ›i. PuteÈ›i observa cÄƒ adresa sa este identicÄƒ cu cea a variabilei ''jiffies_64''.

    Ca sÄƒ exploraÈ›i conÈ›inutul unei variabile pe 64 de biÈ›i, folosiÈ›i, Ã®n GDB, construcÈ›ia
    `<code>`
    x/gx &jiffies

DacÄƒ doreaÈ›i sÄƒ afiÈ™aÈ›i conÈ›inutul variabilei pe 32 de biÈ›i, aÈ›i folosi,
Ã®n GDB, construcÈ›ia

::

    x/wx &jiffies

``</note>`` ### 5. cscope spelunking

FolosiÈ›i LXR sau cscope Ã®n directorul ''/usr/src/linux-so2/'' pentru a
determina locul de definire al unor structuri sau funcÈ›ii.

FiÈ™ierele index cscope sunt deja generate. FolosiÈ›i direct Vim È™i
comenzile aferente pentru parcurgerea codului sursÄƒ. De exemplu,
folosiÈ›i comanda

::

    vim

pentru a deschide editorul Vim. Apoi, Ã®n cadrul editorului, folosiÈ›i
comenzi precum '':cs find g task\_struct''.

DeterminaÈ›i fiÈ™ierul Ã®n care sunt definite urmÄƒtoarele tipuri de date:

-  ''struct task\_struct''

-  ''struct semaphore''

-  ''struct list\_head''

-  ''spinlock\_t''

-  ''struct file\_system\_type''

``<note tip>`` Pentru o structurÄƒ se cautÄƒ doar numele ei. Spre exemplu,
Ã®n cazul ''struct task\_struct'' se cautÄƒ È™irul ''task\_struct''.

De obicei veÈ›i obÈ›ine mai multe match-uri caz Ã®n care: 1. ListaÈ›i toate
match-urile folosind, Ã®n Vim, comanda '':copen''. VÄƒ apare o fereastrÄƒ
secundarÄƒ cu toate match-urile. 2. CÄƒutaÈ›i match-ul potrivit (Ã®n care
este definitÄƒ structura) cÄƒutÃ¢nd dupÄƒ acoladÄƒ deschisÄƒ (''{''), un
caracter sigur pe linia de definire a structurii. Pentru cÄƒutarea
acoladei deschise folosiÈ›i, Ã®n Vim, construcÈ›ia ''/{''. 3. Pe linia
aferentÄƒ apÄƒsaÈ›i ''Enter'' ca sÄƒ vÄƒ ajungÄƒ editorul Ã®n codul sursÄƒ unde
e definitÄƒ varibila. 4. ÃŽnchideÈ›i fereastra secundarÄƒ folosind coamanda
'':cclose''. ``</note>``

DeterminaÈ›i fiÈ™ierul Ã®n care sunt declarate urmÄƒtoarele variabile
globale la nivelul nucleului:

-  ''sys\_call\_table''

-  ''file\_systems''

-  ''current''

-  ''chrdevs''

``<note tip>`` Pentru aceasta folosiÈ›i Ã®n Vim o comandÄƒ de forma '':cs f
g ``<symbol>`` (unde construcÈ›ia ``<symbol>`` reprezintÄƒ numele
simbolului cÄƒutat). ``</note>``

DeterminaÈ›i fiÈ™ierul Ã®n care sunt declarate urmÄƒtoarele funcÈ›ii:

-  ''copy\_from\_user''

-  ''vmalloc''

-  ''schedule\_timeout''

-  ''add\_timer''

``<note tip>`` Pentru aceasta folosiÈ›i Ã®n Vim o comandÄƒ de forma '':cs f
g ``<symbol>`` (unde construcÈ›ia ``<symbol>`` reprezintÄƒ numele
simbolului cÄƒutat). ``</note>``

ParcurgeÈ›i secvenÈ›a de structuri: 1. ''struct task\_struct'' 2. ''struct
mm\_struct'' 3. ''struct vm\_area\_struct'' 4. ''struct
vm\_operations\_struct'' AdicÄƒ parcurgeÈ›i din aproape Ã®n aproape
structurile: accesaÈ›i o structurÄƒ È™i apoi gÄƒsiÈ›i cÃ¢mpuri cu tipul de
date al urmÄƒtoarei structuri, accesaÈ›i-o pe aceasta etc. ReÈ›ineÈ›i Ã®n ce
fiÈ™iere sunt definite; o sÄƒ vÄƒ fie utile la alte laboratoare.

``<note tip>`` Pentru a cÄƒuta un simbol Ã®n Vim (cu suport ''cscope'')
atunci cÃ¢nd sunteÈ›i plasaÈ›i cu cursorul pe acesta, folosiÈ›i construcÈ›ia
''Ctrl+]''.

Pentru a reveni Ã®n match-ul anterior (Ã®nante de cÄƒutare/salt) folosiÈ›i
construcÈ›ia ''Ctrl+o''. Pentru a avansa Ã®n cÄƒutare (pentru a reveni la
match-urile de dinainte de ''Ctrl+o'') folosiÈ›i construcÈ›ia ''Ctrl+i''.
``</note>``

La fel ca mai sus, parcurgeÈ›i secvenÈ›a de apeluri de funcÈ›ii: 1.
''bio\_alloc'' 2. ''bio\_alloc\_bioset'' 3. ''bvec\_alloc'' 4.
''kmem\_cache\_alloc'' 5. ''slab\_alloc''

``<note tip>`` CitiÈ›i secÈ›iunile `cscope <#cscope>`__ sau `LXR
Cross-Reference <#LXR%20Cross-Reference>`__ din laborator. ``</note>``
### SoluÈ›ii

/\*

-  `SoluÈ›ii exerciÈ›ii laborator
   1 <http://elf.cs.pub.ro/so2/res/laboratoare/lab01-sol.zip>`__ \*/
